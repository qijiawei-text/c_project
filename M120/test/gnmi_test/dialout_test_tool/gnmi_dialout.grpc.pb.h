/* Generated by the gRPC C++ plugin. */
/* If you make any local change, they will be lost. */
/* source: gnmi_dialout.proto */
#ifndef GRPC_gnmi_5fdialout_2eproto__INCLUDED
#define GRPC_gnmi_5fdialout_2eproto__INCLUDED

#include "gnmi_dialout.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace gnmi_dialout {

/* gNMIDialOut defines a service which is used by a target system (typically a */
/* network element) to initiate connections to a client (collector). The server */
/* is implemented at the collector, such that the target can initiate connections */
/* to the collector, based on a configured set of telemetry subscriptions. */
class gNMIDialout final {
public:
    static constexpr char const *
    service_full_name()
    {
        return "gnmi_dialout.gNMIDialout";
    }
    class StubInterface {
public:
        virtual
        ~StubInterface()
        {
        }
        /* Publish allows the target to send telemetry updates (in the form of */
        /* SubscribeResponse messaages, which have the same semantics as in the */
        /* gNMI Subscribe RPC, to a client. The client may optionally return the */
        /* PublishResponse message in response to the dial-out connection from the */
        /* target. In this case, the client may modify the set of subscriptions */
        /* that are to be published by the target by: */
        /*   - Specifying a persistent_subscription_name within the PublishResponse message. In this */
        /*     case the target should match pre-configured subscriptions the specified */
        /*         name, and send data only for the paths associated with the */
        /*     specified name. */
        /*       - Specifying a SubscribeRequest message within the subscriptions field of */
        /*         the PublishResponse message. This message has the same semantics as */
        /*     in the Subscribe gNMI RPC. */
        /* In the case that the client specifies neither option, a default set of */
        /* subscriptions (which should be configurable on the target) should be */
        /* published to the client (collector). */
        /*  */
        /* The configuration of subscriptions associated with the publish RPC must */
        /* be through the OpenConfig telemetry configuration and operational state */
        /* model: */
        /* https://github.com/openconfig/public/blob/master/release/models/telemetry/openconfig-telemetry.yang */
        std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> >
        Publish(::grpc::ClientContext *context)
        {
            return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> >(PublishRaw(context));
        }
        std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> >
        AsyncPublish(::grpc::ClientContext *context, ::grpc::CompletionQueue *cq, void *tag)
        {
            return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> >(AsyncPublishRaw(context, cq, tag));
        }
        std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> >
        PrepareAsyncPublish(::grpc::ClientContext *context, ::grpc::CompletionQueue *cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> >(PrepareAsyncPublishRaw(context, cq));
        }
        class experimental_async_interface {
public:
            virtual
            ~experimental_async_interface()
            {
            }
            /* Publish allows the target to send telemetry updates (in the form of */
            /* SubscribeResponse messaages, which have the same semantics as in the */
            /* gNMI Subscribe RPC, to a client. The client may optionally return the */
            /* PublishResponse message in response to the dial-out connection from the */
            /* target. In this case, the client may modify the set of subscriptions */
            /* that are to be published by the target by: */
            /*   - Specifying a persistent_subscription_name within the PublishResponse message. In this */
            /*     case the target should match pre-configured subscriptions the specified */
            /*     name, and send data only for the paths associated with the */
            /*     specified name. */
            /*   - Specifying a SubscribeRequest message within the subscriptions field of */
            /*     the PublishResponse message. This message has the same semantics as */
            /*     in the Subscribe gNMI RPC. */
            /* In the case that the client specifies neither option, a default set of */
            /* subscriptions (which should be configurable on the target) should be */
            /* published to the client (collector). */
            /*  */
            /* The configuration of subscriptions associated with the publish RPC must */
            /* be through the OpenConfig telemetry configuration and operational state */
            /* model: */
            /* https://github.com/openconfig/public/blob/master/release/models/telemetry/openconfig-telemetry.yang */
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void Publish(::grpc::ClientContext *context, ::grpc::ClientBidiReactor< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> *reactor) = 0;
      #else
            virtual void Publish(::grpc::ClientContext *context, ::grpc::experimental::ClientBidiReactor< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> *reactor) = 0;
      #endif
        };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        async_interface *
        async()
        {
            return experimental_async();
        }
    #endif
        virtual class experimental_async_interface *
        experimental_async()
        {
            return nullptr;
        }
private:
        virtual ::grpc::ClientReaderWriterInterface< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> *PublishRaw(::grpc::ClientContext * context) = 0;
        virtual ::grpc::ClientAsyncReaderWriterInterface< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> *AsyncPublishRaw(::grpc::ClientContext * context, ::grpc::CompletionQueue * cq, void *tag) = 0;
        virtual ::grpc::ClientAsyncReaderWriterInterface< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> *PrepareAsyncPublishRaw(::grpc::ClientContext * context, ::grpc::CompletionQueue * cq) = 0;
    };
    class Stub final : public StubInterface {
public:
        Stub(const std::shared_ptr< ::grpc::ChannelInterface>&channel);
        std::unique_ptr< ::grpc::ClientReaderWriter< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> >
        Publish(::grpc::ClientContext *context)
        {
            return std::unique_ptr< ::grpc::ClientReaderWriter< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> >(PublishRaw(context));
        }
        std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> >
        AsyncPublish(::grpc::ClientContext *context, ::grpc::CompletionQueue *cq, void *tag)
        {
            return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> >(AsyncPublishRaw(context, cq, tag));
        }
        std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> >
        PrepareAsyncPublish(::grpc::ClientContext *context, ::grpc::CompletionQueue *cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> >(PrepareAsyncPublishRaw(context, cq));
        }
        class experimental_async final :
            public StubInterface::experimental_async_interface {
public:
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void Publish(::grpc::ClientContext *context, ::grpc::ClientBidiReactor< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> *reactor) override;
      #else
            void Publish(::grpc::ClientContext *context, ::grpc::experimental::ClientBidiReactor< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> *reactor) override;
      #endif
private:
            friend class Stub;
            explicit
            experimental_async(Stub *stub) : stub_(stub) {
            }
            Stub *
            stub()
            {
                return stub_;
            }
            Stub *stub_;
        };
        class experimental_async_interface *
        experimental_async() override
        {
            return &async_stub_;
        }

private:
        std::shared_ptr< ::grpc::ChannelInterface> channel_;
        class experimental_async async_stub_ {this};
        ::grpc::ClientReaderWriter< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> *PublishRaw(::grpc::ClientContext * context) override;
        ::grpc::ClientAsyncReaderWriter< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> *AsyncPublishRaw(::grpc::ClientContext * context, ::grpc::CompletionQueue * cq, void *tag) override;
        ::grpc::ClientAsyncReaderWriter< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> *PrepareAsyncPublishRaw(::grpc::ClientContext * context, ::grpc::CompletionQueue * cq) override;
        const ::grpc::internal::RpcMethod rpcmethod_Publish_;
    };
    static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

    class Service : public ::grpc::Service {
public:
        Service();
        virtual
        ~Service();
        /* Publish allows the target to send telemetry updates (in the form of */
        /* SubscribeResponse messaages, which have the same semantics as in the */
        /* gNMI Subscribe RPC, to a client. The client may optionally return the */
        /* PublishResponse message in response to the dial-out connection from the */
        /* target. In this case, the client may modify the set of subscriptions */
        /* that are to be published by the target by: */
        /*   - Specifying a persistent_subscription_name within the PublishResponse message. In this */
        /*     case the target should match pre-configured subscriptions the specified */
        /*         name, and send data only for the paths associated with the */
        /*     specified name. */
        /*       - Specifying a SubscribeRequest message within the subscriptions field of */
        /*         the PublishResponse message. This message has the same semantics as */
        /*     in the Subscribe gNMI RPC. */
        /* In the case that the client specifies neither option, a default set of */
        /* subscriptions (which should be configurable on the target) should be */
        /* published to the client (collector). */
        /*  */
        /* The configuration of subscriptions associated with the publish RPC must */
        /* be through the OpenConfig telemetry configuration and operational state */
        /* model: */
        /* https://github.com/openconfig/public/blob/master/release/models/telemetry/openconfig-telemetry.yang */
        virtual ::grpc::Status Publish(::grpc::ServerContext *context, ::grpc::ServerReaderWriter< ::gnmi_dialout::PublishResponse, ::gnmi::SubscribeResponse> *stream);
    };
    template <class BaseClass>
    class WithAsyncMethod_Publish : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithAsyncMethod_Publish()
        {
            ::grpc::Service::MarkMethodAsync(0);
        }
        ~WithAsyncMethod_Publish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Publish(::grpc::ServerContext * /*context*/, ::grpc::ServerReaderWriter< ::gnmi_dialout::PublishResponse, ::gnmi::SubscribeResponse> * /*stream*/)  override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void
        RequestPublish(::grpc::ServerContext *context, ::grpc::ServerAsyncReaderWriter< ::gnmi_dialout::PublishResponse, ::gnmi::SubscribeResponse> *stream, ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq, void *tag)
        {
            ::grpc::Service::RequestAsyncBidiStreaming(0, context, stream, new_call_cq, notification_cq, tag);
        }
    };
    typedef WithAsyncMethod_Publish<Service > AsyncService;
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_Publish : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        ExperimentalWithCallbackMethod_Publish()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(0,
                               new ::grpc_impl::internal::CallbackBidiHandler< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse>(
                                   [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                       ::grpc::CallbackServerContext *
    #else
                                       ::grpc::experimental::CallbackServerContext *
    #endif
                                       context) {return this->Publish(context); }));
        }
        ~ExperimentalWithCallbackMethod_Publish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Publish(::grpc::ServerContext * /*context*/, ::grpc::ServerReaderWriter< ::gnmi_dialout::PublishResponse, ::gnmi::SubscribeResponse> * /*stream*/)  override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerBidiReactor< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> *Publish(
            ::grpc::CallbackServerContext * /*context*/)
    #else
        virtual ::grpc::experimental::ServerBidiReactor< ::gnmi::SubscribeResponse, ::gnmi_dialout::PublishResponse> *Publish(
            ::grpc::experimental::CallbackServerContext * /*context*/)
    #endif
        {
            return nullptr;
        }
    };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef ExperimentalWithCallbackMethod_Publish<Service > CallbackService;
  #endif

    typedef ExperimentalWithCallbackMethod_Publish<Service > ExperimentalCallbackService;
    template <class BaseClass>
    class WithGenericMethod_Publish : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithGenericMethod_Publish()
        {
            ::grpc::Service::MarkMethodGeneric(0);
        }
        ~WithGenericMethod_Publish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Publish(::grpc::ServerContext * /*context*/, ::grpc::ServerReaderWriter< ::gnmi_dialout::PublishResponse, ::gnmi::SubscribeResponse> * /*stream*/)  override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithRawMethod_Publish : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithRawMethod_Publish()
        {
            ::grpc::Service::MarkMethodRaw(0);
        }
        ~WithRawMethod_Publish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Publish(::grpc::ServerContext * /*context*/, ::grpc::ServerReaderWriter< ::gnmi_dialout::PublishResponse, ::gnmi::SubscribeResponse> * /*stream*/)  override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void
        RequestPublish(::grpc::ServerContext *context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer> *stream, ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq, void *tag)
        {
            ::grpc::Service::RequestAsyncBidiStreaming(0, context, stream, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_Publish : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        ExperimentalWithRawCallbackMethod_Publish()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(0,
                                  new ::grpc_impl::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                                      [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                          ::grpc::CallbackServerContext *
    #else
                                          ::grpc::experimental::CallbackServerContext *
    #endif
                                          context) {return this->Publish(context); }));
        }
        ~ExperimentalWithRawCallbackMethod_Publish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Publish(::grpc::ServerContext * /*context*/, ::grpc::ServerReaderWriter< ::gnmi_dialout::PublishResponse, ::gnmi::SubscribeResponse> * /*stream*/)  override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer> *Publish(
            ::grpc::CallbackServerContext * /*context*/)
    #else
        virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer> *Publish(
            ::grpc::experimental::CallbackServerContext * /*context*/)
    #endif
        {
            return nullptr;
        }
    };
    typedef Service StreamedUnaryService;
    typedef Service SplitStreamedService;
    typedef Service StreamedService;
};

}  /* namespace gnmi_dialout */


#endif  /* GRPC_gnmi_5fdialout_2eproto__INCLUDED */
