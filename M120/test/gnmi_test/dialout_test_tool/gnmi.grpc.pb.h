/* Generated by the gRPC C++ plugin. */
/* If you make any local change, they will be lost. */
/* source: gnmi.proto */
/* Original file comments: */
/*  */
/* Copyright 2016 Google Inc. All Rights Reserved. */
/*  */
/* Licensed under the Apache License, Version 2.0 (the "License"); */
/* you may not use this file except in compliance with the License. */
/* You may obtain a copy of the License at */
/*  */
/*    http://www.apache.org/licenses/LICENSE-2.0 */
/*  */
/* Unless required by applicable law or agreed to in writing, software */
/* distributed under the License is distributed on an "AS IS" BASIS, */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. */
/* See the License for the specific language governing permissions and */
/* limitations under the License. */
/*  */
#ifndef GRPC_gnmi_2eproto__INCLUDED
#define GRPC_gnmi_2eproto__INCLUDED

#include "gnmi.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace gnmi {

class gNMI final {
public:
    static constexpr char const *
    service_full_name()
    {
        return "gnmi.gNMI";
    }
    class StubInterface {
public:
        virtual
        ~StubInterface()
        {
        }
        /* Capabilities allows the client to retrieve the set of capabilities that */
        /* is supported by the target. This allows the target to validate the */
        /* service version that is implemented and retrieve the set of models that */
        /* the target supports. The models can then be specified in subsequent RPCs */
        /* to restrict the set of data that is utilized. */
        /* Reference: gNMI Specification Section 3.2 */
        virtual ::grpc::Status Capabilities(::grpc::ClientContext *context, const ::gnmi::CapabilityRequest& request, ::gnmi::CapabilityResponse *response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::CapabilityResponse> >
        AsyncCapabilities(::grpc::ClientContext *context, const ::gnmi::CapabilityRequest& request, ::grpc::CompletionQueue *cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::CapabilityResponse> >(AsyncCapabilitiesRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::CapabilityResponse> >
        PrepareAsyncCapabilities(::grpc::ClientContext *context, const ::gnmi::CapabilityRequest& request, ::grpc::CompletionQueue *cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::CapabilityResponse> >(PrepareAsyncCapabilitiesRaw(context, request, cq));
        }
        /* Retrieve a snapshot of data from the target. A Get RPC requests that the */
        /* target snapshots a subset of the data tree as specified by the paths */
        /* included in the message and serializes this to be returned to the */
        /* client using the specified encoding. */
        /* Reference: gNMI Specification Section 3.3 */
        virtual ::grpc::Status Get(::grpc::ClientContext *context, const ::gnmi::GetRequest& request, ::gnmi::GetResponse *response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::GetResponse> >
        AsyncGet(::grpc::ClientContext *context, const ::gnmi::GetRequest& request, ::grpc::CompletionQueue *cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::GetResponse> >(AsyncGetRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::GetResponse> >
        PrepareAsyncGet(::grpc::ClientContext *context, const ::gnmi::GetRequest& request, ::grpc::CompletionQueue *cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::GetResponse> >(PrepareAsyncGetRaw(context, request, cq));
        }
        /* Set allows the client to modify the state of data on the target. The */
        /* paths to modified along with the new values that the client wishes */
        /* to set the value to. */
        /* Reference: gNMI Specification Section 3.4 */
        virtual ::grpc::Status Set(::grpc::ClientContext *context, const ::gnmi::SetRequest& request, ::gnmi::SetResponse *response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::SetResponse> >
        AsyncSet(::grpc::ClientContext *context, const ::gnmi::SetRequest& request, ::grpc::CompletionQueue *cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::SetResponse> >(AsyncSetRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::SetResponse> >
        PrepareAsyncSet(::grpc::ClientContext *context, const ::gnmi::SetRequest& request, ::grpc::CompletionQueue *cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::SetResponse> >(PrepareAsyncSetRaw(context, request, cq));
        }
        /* Subscribe allows a client to request the target to send it values */
        /* of particular paths within the data tree. These values may be streamed */
        /* at a particular cadence (STREAM), sent one off on a long-lived channel */
        /* (POLL), or sent as a one-off retrieval (ONCE). */
        /* Reference: gNMI Specification Section 3.5 */
        std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> >
        Subscribe(::grpc::ClientContext *context)
        {
            return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> >(SubscribeRaw(context));
        }
        std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> >
        AsyncSubscribe(::grpc::ClientContext *context, ::grpc::CompletionQueue *cq, void *tag)
        {
            return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> >(AsyncSubscribeRaw(context, cq, tag));
        }
        std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> >
        PrepareAsyncSubscribe(::grpc::ClientContext *context, ::grpc::CompletionQueue *cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> >(PrepareAsyncSubscribeRaw(context, cq));
        }
        class experimental_async_interface {
public:
            virtual
            ~experimental_async_interface()
            {
            }
            /* Capabilities allows the client to retrieve the set of capabilities that */
            /* is supported by the target. This allows the target to validate the */
            /* service version that is implemented and retrieve the set of models that */
            /* the target supports. The models can then be specified in subsequent RPCs */
            /* to restrict the set of data that is utilized. */
            /* Reference: gNMI Specification Section 3.2 */
            virtual void Capabilities(::grpc::ClientContext *context, const ::gnmi::CapabilityRequest *request, ::gnmi::CapabilityResponse *response, std::function<void(::grpc::Status)>) = 0;
            virtual void Capabilities(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::CapabilityResponse *response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void Capabilities(::grpc::ClientContext *context, const ::gnmi::CapabilityRequest *request, ::gnmi::CapabilityResponse *response, ::grpc::ClientUnaryReactor *reactor) = 0;
      #else
            virtual void Capabilities(::grpc::ClientContext *context, const ::gnmi::CapabilityRequest *request, ::gnmi::CapabilityResponse *response, ::grpc::experimental::ClientUnaryReactor *reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void Capabilities(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::CapabilityResponse *response, ::grpc::ClientUnaryReactor *reactor) = 0;
      #else
            virtual void Capabilities(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::CapabilityResponse *response, ::grpc::experimental::ClientUnaryReactor *reactor) = 0;
      #endif
            /* Retrieve a snapshot of data from the target. A Get RPC requests that the */
            /* target snapshots a subset of the data tree as specified by the paths */
            /* included in the message and serializes this to be returned to the */
            /* client using the specified encoding. */
            /* Reference: gNMI Specification Section 3.3 */
            virtual void Get(::grpc::ClientContext *context, const ::gnmi::GetRequest *request, ::gnmi::GetResponse *response, std::function<void(::grpc::Status)>) = 0;
            virtual void Get(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::GetResponse *response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void Get(::grpc::ClientContext *context, const ::gnmi::GetRequest *request, ::gnmi::GetResponse *response, ::grpc::ClientUnaryReactor *reactor) = 0;
      #else
            virtual void Get(::grpc::ClientContext *context, const ::gnmi::GetRequest *request, ::gnmi::GetResponse *response, ::grpc::experimental::ClientUnaryReactor *reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void Get(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::GetResponse *response, ::grpc::ClientUnaryReactor *reactor) = 0;
      #else
            virtual void Get(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::GetResponse *response, ::grpc::experimental::ClientUnaryReactor *reactor) = 0;
      #endif
            /* Set allows the client to modify the state of data on the target. The */
            /* paths to modified along with the new values that the client wishes */
            /* to set the value to. */
            /* Reference: gNMI Specification Section 3.4 */
            virtual void Set(::grpc::ClientContext *context, const ::gnmi::SetRequest *request, ::gnmi::SetResponse *response, std::function<void(::grpc::Status)>) = 0;
            virtual void Set(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::SetResponse *response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void Set(::grpc::ClientContext *context, const ::gnmi::SetRequest *request, ::gnmi::SetResponse *response, ::grpc::ClientUnaryReactor *reactor) = 0;
      #else
            virtual void Set(::grpc::ClientContext *context, const ::gnmi::SetRequest *request, ::gnmi::SetResponse *response, ::grpc::experimental::ClientUnaryReactor *reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void Set(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::SetResponse *response, ::grpc::ClientUnaryReactor *reactor) = 0;
      #else
            virtual void Set(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::SetResponse *response, ::grpc::experimental::ClientUnaryReactor *reactor) = 0;
      #endif
            /* Subscribe allows a client to request the target to send it values */
            /* of particular paths within the data tree. These values may be streamed */
            /* at a particular cadence (STREAM), sent one off on a long-lived channel */
            /* (POLL), or sent as a one-off retrieval (ONCE). */
            /* Reference: gNMI Specification Section 3.5 */
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void Subscribe(::grpc::ClientContext *context, ::grpc::ClientBidiReactor< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> *reactor) = 0;
      #else
            virtual void Subscribe(::grpc::ClientContext *context, ::grpc::experimental::ClientBidiReactor< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> *reactor) = 0;
      #endif
        };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        async_interface *
        async()
        {
            return experimental_async();
        }
    #endif
        virtual class experimental_async_interface *
        experimental_async()
        {
            return nullptr;
        }
private:
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::CapabilityResponse> *AsyncCapabilitiesRaw(::grpc::ClientContext * context, const ::gnmi::CapabilityRequest & request, ::grpc::CompletionQueue * cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::CapabilityResponse> *PrepareAsyncCapabilitiesRaw(::grpc::ClientContext * context, const ::gnmi::CapabilityRequest & request, ::grpc::CompletionQueue * cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::GetResponse> *AsyncGetRaw(::grpc::ClientContext * context, const ::gnmi::GetRequest & request, ::grpc::CompletionQueue * cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::GetResponse> *PrepareAsyncGetRaw(::grpc::ClientContext * context, const ::gnmi::GetRequest & request, ::grpc::CompletionQueue * cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::SetResponse> *AsyncSetRaw(::grpc::ClientContext * context, const ::gnmi::SetRequest & request, ::grpc::CompletionQueue * cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::gnmi::SetResponse> *PrepareAsyncSetRaw(::grpc::ClientContext * context, const ::gnmi::SetRequest & request, ::grpc::CompletionQueue * cq) = 0;
        virtual ::grpc::ClientReaderWriterInterface< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> *SubscribeRaw(::grpc::ClientContext * context) = 0;
        virtual ::grpc::ClientAsyncReaderWriterInterface< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> *AsyncSubscribeRaw(::grpc::ClientContext * context, ::grpc::CompletionQueue * cq, void *tag) = 0;
        virtual ::grpc::ClientAsyncReaderWriterInterface< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> *PrepareAsyncSubscribeRaw(::grpc::ClientContext * context, ::grpc::CompletionQueue * cq) = 0;
    };
    class Stub final : public StubInterface {
public:
        Stub(const std::shared_ptr< ::grpc::ChannelInterface>&channel);
        ::grpc::Status Capabilities(::grpc::ClientContext *context, const ::gnmi::CapabilityRequest& request, ::gnmi::CapabilityResponse *response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gnmi::CapabilityResponse> >
        AsyncCapabilities(::grpc::ClientContext *context, const ::gnmi::CapabilityRequest& request, ::grpc::CompletionQueue *cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gnmi::CapabilityResponse> >(AsyncCapabilitiesRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gnmi::CapabilityResponse> >
        PrepareAsyncCapabilities(::grpc::ClientContext *context, const ::gnmi::CapabilityRequest& request, ::grpc::CompletionQueue *cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gnmi::CapabilityResponse> >(PrepareAsyncCapabilitiesRaw(context, request, cq));
        }
        ::grpc::Status Get(::grpc::ClientContext *context, const ::gnmi::GetRequest& request, ::gnmi::GetResponse *response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gnmi::GetResponse> >
        AsyncGet(::grpc::ClientContext *context, const ::gnmi::GetRequest& request, ::grpc::CompletionQueue *cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gnmi::GetResponse> >(AsyncGetRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gnmi::GetResponse> >
        PrepareAsyncGet(::grpc::ClientContext *context, const ::gnmi::GetRequest& request, ::grpc::CompletionQueue *cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gnmi::GetResponse> >(PrepareAsyncGetRaw(context, request, cq));
        }
        ::grpc::Status Set(::grpc::ClientContext *context, const ::gnmi::SetRequest& request, ::gnmi::SetResponse *response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gnmi::SetResponse> >
        AsyncSet(::grpc::ClientContext *context, const ::gnmi::SetRequest& request, ::grpc::CompletionQueue *cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gnmi::SetResponse> >(AsyncSetRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gnmi::SetResponse> >
        PrepareAsyncSet(::grpc::ClientContext *context, const ::gnmi::SetRequest& request, ::grpc::CompletionQueue *cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gnmi::SetResponse> >(PrepareAsyncSetRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientReaderWriter< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> >
        Subscribe(::grpc::ClientContext *context)
        {
            return std::unique_ptr< ::grpc::ClientReaderWriter< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> >(SubscribeRaw(context));
        }
        std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> >
        AsyncSubscribe(::grpc::ClientContext *context, ::grpc::CompletionQueue *cq, void *tag)
        {
            return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> >(AsyncSubscribeRaw(context, cq, tag));
        }
        std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> >
        PrepareAsyncSubscribe(::grpc::ClientContext *context, ::grpc::CompletionQueue *cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> >(PrepareAsyncSubscribeRaw(context, cq));
        }
        class experimental_async final :
            public StubInterface::experimental_async_interface {
public:
            void Capabilities(::grpc::ClientContext *context, const ::gnmi::CapabilityRequest *request, ::gnmi::CapabilityResponse *response, std::function<void(::grpc::Status)>) override;
            void Capabilities(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::CapabilityResponse *response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void Capabilities(::grpc::ClientContext *context, const ::gnmi::CapabilityRequest *request, ::gnmi::CapabilityResponse *response, ::grpc::ClientUnaryReactor *reactor) override;
      #else
            void Capabilities(::grpc::ClientContext *context, const ::gnmi::CapabilityRequest *request, ::gnmi::CapabilityResponse *response, ::grpc::experimental::ClientUnaryReactor *reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void Capabilities(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::CapabilityResponse *response, ::grpc::ClientUnaryReactor *reactor) override;
      #else
            void Capabilities(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::CapabilityResponse *response, ::grpc::experimental::ClientUnaryReactor *reactor) override;
      #endif
            void Get(::grpc::ClientContext *context, const ::gnmi::GetRequest *request, ::gnmi::GetResponse *response, std::function<void(::grpc::Status)>) override;
            void Get(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::GetResponse *response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void Get(::grpc::ClientContext *context, const ::gnmi::GetRequest *request, ::gnmi::GetResponse *response, ::grpc::ClientUnaryReactor *reactor) override;
      #else
            void Get(::grpc::ClientContext *context, const ::gnmi::GetRequest *request, ::gnmi::GetResponse *response, ::grpc::experimental::ClientUnaryReactor *reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void Get(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::GetResponse *response, ::grpc::ClientUnaryReactor *reactor) override;
      #else
            void Get(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::GetResponse *response, ::grpc::experimental::ClientUnaryReactor *reactor) override;
      #endif
            void Set(::grpc::ClientContext *context, const ::gnmi::SetRequest *request, ::gnmi::SetResponse *response, std::function<void(::grpc::Status)>) override;
            void Set(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::SetResponse *response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void Set(::grpc::ClientContext *context, const ::gnmi::SetRequest *request, ::gnmi::SetResponse *response, ::grpc::ClientUnaryReactor *reactor) override;
      #else
            void Set(::grpc::ClientContext *context, const ::gnmi::SetRequest *request, ::gnmi::SetResponse *response, ::grpc::experimental::ClientUnaryReactor *reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void Set(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::SetResponse *response, ::grpc::ClientUnaryReactor *reactor) override;
      #else
            void Set(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request, ::gnmi::SetResponse *response, ::grpc::experimental::ClientUnaryReactor *reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void Subscribe(::grpc::ClientContext *context, ::grpc::ClientBidiReactor< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> *reactor) override;
      #else
            void Subscribe(::grpc::ClientContext *context, ::grpc::experimental::ClientBidiReactor< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> *reactor) override;
      #endif
private:
            friend class Stub;
            explicit
            experimental_async(Stub *stub) : stub_(stub) {
            }
            Stub *
            stub()
            {
                return stub_;
            }
            Stub *stub_;
        };
        class experimental_async_interface *
        experimental_async() override
        {
            return &async_stub_;
        }

private:
        std::shared_ptr< ::grpc::ChannelInterface> channel_;
        class experimental_async async_stub_ {this};
        ::grpc::ClientAsyncResponseReader< ::gnmi::CapabilityResponse> *AsyncCapabilitiesRaw(::grpc::ClientContext * context, const ::gnmi::CapabilityRequest & request, ::grpc::CompletionQueue * cq) override;
        ::grpc::ClientAsyncResponseReader< ::gnmi::CapabilityResponse> *PrepareAsyncCapabilitiesRaw(::grpc::ClientContext * context, const ::gnmi::CapabilityRequest & request, ::grpc::CompletionQueue * cq) override;
        ::grpc::ClientAsyncResponseReader< ::gnmi::GetResponse> *AsyncGetRaw(::grpc::ClientContext * context, const ::gnmi::GetRequest & request, ::grpc::CompletionQueue * cq) override;
        ::grpc::ClientAsyncResponseReader< ::gnmi::GetResponse> *PrepareAsyncGetRaw(::grpc::ClientContext * context, const ::gnmi::GetRequest & request, ::grpc::CompletionQueue * cq) override;
        ::grpc::ClientAsyncResponseReader< ::gnmi::SetResponse> *AsyncSetRaw(::grpc::ClientContext * context, const ::gnmi::SetRequest & request, ::grpc::CompletionQueue * cq) override;
        ::grpc::ClientAsyncResponseReader< ::gnmi::SetResponse> *PrepareAsyncSetRaw(::grpc::ClientContext * context, const ::gnmi::SetRequest & request, ::grpc::CompletionQueue * cq) override;
        ::grpc::ClientReaderWriter< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> *SubscribeRaw(::grpc::ClientContext * context) override;
        ::grpc::ClientAsyncReaderWriter< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> *AsyncSubscribeRaw(::grpc::ClientContext * context, ::grpc::CompletionQueue * cq, void *tag) override;
        ::grpc::ClientAsyncReaderWriter< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> *PrepareAsyncSubscribeRaw(::grpc::ClientContext * context, ::grpc::CompletionQueue * cq) override;
        const ::grpc::internal::RpcMethod rpcmethod_Capabilities_;
        const ::grpc::internal::RpcMethod rpcmethod_Get_;
        const ::grpc::internal::RpcMethod rpcmethod_Set_;
        const ::grpc::internal::RpcMethod rpcmethod_Subscribe_;
    };
    static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

    class Service : public ::grpc::Service {
public:
        Service();
        virtual
        ~Service();
        /* Capabilities allows the client to retrieve the set of capabilities that */
        /* is supported by the target. This allows the target to validate the */
        /* service version that is implemented and retrieve the set of models that */
        /* the target supports. The models can then be specified in subsequent RPCs */
        /* to restrict the set of data that is utilized. */
        /* Reference: gNMI Specification Section 3.2 */
        virtual ::grpc::Status Capabilities(::grpc::ServerContext *context, const ::gnmi::CapabilityRequest *request, ::gnmi::CapabilityResponse *response);
        /* Retrieve a snapshot of data from the target. A Get RPC requests that the */
        /* target snapshots a subset of the data tree as specified by the paths */
        /* included in the message and serializes this to be returned to the */
        /* client using the specified encoding. */
        /* Reference: gNMI Specification Section 3.3 */
        virtual ::grpc::Status Get(::grpc::ServerContext *context, const ::gnmi::GetRequest *request, ::gnmi::GetResponse *response);
        /* Set allows the client to modify the state of data on the target. The */
        /* paths to modified along with the new values that the client wishes */
        /* to set the value to. */
        /* Reference: gNMI Specification Section 3.4 */
        virtual ::grpc::Status Set(::grpc::ServerContext *context, const ::gnmi::SetRequest *request, ::gnmi::SetResponse *response);
        /* Subscribe allows a client to request the target to send it values */
        /* of particular paths within the data tree. These values may be streamed */
        /* at a particular cadence (STREAM), sent one off on a long-lived channel */
        /* (POLL), or sent as a one-off retrieval (ONCE). */
        /* Reference: gNMI Specification Section 3.5 */
        virtual ::grpc::Status Subscribe(::grpc::ServerContext *context, ::grpc::ServerReaderWriter< ::gnmi::SubscribeResponse, ::gnmi::SubscribeRequest> *stream);
    };
    template <class BaseClass>
    class WithAsyncMethod_Capabilities : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithAsyncMethod_Capabilities()
        {
            ::grpc::Service::MarkMethodAsync(0);
        }
        ~WithAsyncMethod_Capabilities() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Capabilities(::grpc::ServerContext * /*context*/, const ::gnmi::CapabilityRequest * /*request*/, ::gnmi::CapabilityResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void
        RequestCapabilities(::grpc::ServerContext *context, ::gnmi::CapabilityRequest *request, ::grpc::ServerAsyncResponseWriter< ::gnmi::CapabilityResponse> *response, ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq, void *tag)
        {
            ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_Get : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithAsyncMethod_Get()
        {
            ::grpc::Service::MarkMethodAsync(1);
        }
        ~WithAsyncMethod_Get() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Get(::grpc::ServerContext * /*context*/, const ::gnmi::GetRequest * /*request*/, ::gnmi::GetResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void
        RequestGet(::grpc::ServerContext *context, ::gnmi::GetRequest *request, ::grpc::ServerAsyncResponseWriter< ::gnmi::GetResponse> *response, ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq, void *tag)
        {
            ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_Set : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithAsyncMethod_Set()
        {
            ::grpc::Service::MarkMethodAsync(2);
        }
        ~WithAsyncMethod_Set() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Set(::grpc::ServerContext * /*context*/, const ::gnmi::SetRequest * /*request*/, ::gnmi::SetResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void
        RequestSet(::grpc::ServerContext *context, ::gnmi::SetRequest *request, ::grpc::ServerAsyncResponseWriter< ::gnmi::SetResponse> *response, ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq, void *tag)
        {
            ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_Subscribe : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithAsyncMethod_Subscribe()
        {
            ::grpc::Service::MarkMethodAsync(3);
        }
        ~WithAsyncMethod_Subscribe() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Subscribe(::grpc::ServerContext * /*context*/, ::grpc::ServerReaderWriter< ::gnmi::SubscribeResponse, ::gnmi::SubscribeRequest> * /*stream*/)  override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void
        RequestSubscribe(::grpc::ServerContext *context, ::grpc::ServerAsyncReaderWriter< ::gnmi::SubscribeResponse, ::gnmi::SubscribeRequest> *stream, ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq, void *tag)
        {
            ::grpc::Service::RequestAsyncBidiStreaming(3, context, stream, new_call_cq, notification_cq, tag);
        }
    };
    typedef WithAsyncMethod_Capabilities<WithAsyncMethod_Get<WithAsyncMethod_Set<WithAsyncMethod_Subscribe<Service > > > > AsyncService;
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_Capabilities : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        ExperimentalWithCallbackMethod_Capabilities()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(0,
                               new ::grpc_impl::internal::CallbackUnaryHandler< ::gnmi::CapabilityRequest, ::gnmi::CapabilityResponse>(
                                   [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                       ::grpc::CallbackServerContext *
    #else
                                       ::grpc::experimental::CallbackServerContext *
    #endif
                                       context, const ::gnmi::CapabilityRequest * request, ::gnmi::CapabilityResponse * response) {return this->Capabilities(context, request, response); }));
        }
        void
        SetMessageAllocatorFor_Capabilities(
            ::grpc::experimental::MessageAllocator< ::gnmi::CapabilityRequest, ::gnmi::CapabilityResponse> *allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler * const handler = ::grpc::Service::GetHandler(0);
    #else
            ::grpc::internal::MethodHandler * const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
            static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::gnmi::CapabilityRequest, ::gnmi::CapabilityResponse> *>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_Capabilities() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Capabilities(::grpc::ServerContext * /*context*/, const ::gnmi::CapabilityRequest * /*request*/, ::gnmi::CapabilityResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor *Capabilities(
            ::grpc::CallbackServerContext * /*context*/, const ::gnmi::CapabilityRequest * /*request*/, ::gnmi::CapabilityResponse * /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor * Capabilities(
            ::grpc::experimental::CallbackServerContext * /*context*/, const ::gnmi::CapabilityRequest * /*request*/, ::gnmi::CapabilityResponse * /*response*/)
    #endif
        {
            return nullptr;
        }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_Get : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        ExperimentalWithCallbackMethod_Get()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(1,
                               new ::grpc_impl::internal::CallbackUnaryHandler< ::gnmi::GetRequest, ::gnmi::GetResponse>(
                                   [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                       ::grpc::CallbackServerContext *
    #else
                                       ::grpc::experimental::CallbackServerContext *
    #endif
                                       context, const ::gnmi::GetRequest * request, ::gnmi::GetResponse * response) {return this->Get(context, request, response); }));
        }
        void
        SetMessageAllocatorFor_Get(
            ::grpc::experimental::MessageAllocator< ::gnmi::GetRequest, ::gnmi::GetResponse> *allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler * const handler = ::grpc::Service::GetHandler(1);
    #else
            ::grpc::internal::MethodHandler * const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
            static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::gnmi::GetRequest, ::gnmi::GetResponse> *>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_Get() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Get(::grpc::ServerContext * /*context*/, const ::gnmi::GetRequest * /*request*/, ::gnmi::GetResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor *Get(
            ::grpc::CallbackServerContext * /*context*/, const ::gnmi::GetRequest * /*request*/, ::gnmi::GetResponse * /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor * Get(
            ::grpc::experimental::CallbackServerContext * /*context*/, const ::gnmi::GetRequest * /*request*/, ::gnmi::GetResponse * /*response*/)
    #endif
        {
            return nullptr;
        }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_Set : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        ExperimentalWithCallbackMethod_Set()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(2,
                               new ::grpc_impl::internal::CallbackUnaryHandler< ::gnmi::SetRequest, ::gnmi::SetResponse>(
                                   [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                       ::grpc::CallbackServerContext *
    #else
                                       ::grpc::experimental::CallbackServerContext *
    #endif
                                       context, const ::gnmi::SetRequest * request, ::gnmi::SetResponse * response) {return this->Set(context, request, response); }));
        }
        void
        SetMessageAllocatorFor_Set(
            ::grpc::experimental::MessageAllocator< ::gnmi::SetRequest, ::gnmi::SetResponse> *allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler * const handler = ::grpc::Service::GetHandler(2);
    #else
            ::grpc::internal::MethodHandler * const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
            static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::gnmi::SetRequest, ::gnmi::SetResponse> *>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_Set() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Set(::grpc::ServerContext * /*context*/, const ::gnmi::SetRequest * /*request*/, ::gnmi::SetResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor *Set(
            ::grpc::CallbackServerContext * /*context*/, const ::gnmi::SetRequest * /*request*/, ::gnmi::SetResponse * /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor * Set(
            ::grpc::experimental::CallbackServerContext * /*context*/, const ::gnmi::SetRequest * /*request*/, ::gnmi::SetResponse * /*response*/)
    #endif
        {
            return nullptr;
        }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_Subscribe : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        ExperimentalWithCallbackMethod_Subscribe()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(3,
                               new ::grpc_impl::internal::CallbackBidiHandler< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse>(
                                   [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                       ::grpc::CallbackServerContext *
    #else
                                       ::grpc::experimental::CallbackServerContext *
    #endif
                                       context) {return this->Subscribe(context); }));
        }
        ~ExperimentalWithCallbackMethod_Subscribe() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Subscribe(::grpc::ServerContext * /*context*/, ::grpc::ServerReaderWriter< ::gnmi::SubscribeResponse, ::gnmi::SubscribeRequest> * /*stream*/)  override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerBidiReactor< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> *Subscribe(
            ::grpc::CallbackServerContext * /*context*/)
    #else
        virtual ::grpc::experimental::ServerBidiReactor< ::gnmi::SubscribeRequest, ::gnmi::SubscribeResponse> *Subscribe(
            ::grpc::experimental::CallbackServerContext * /*context*/)
    #endif
        {
            return nullptr;
        }
    };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef ExperimentalWithCallbackMethod_Capabilities<ExperimentalWithCallbackMethod_Get<ExperimentalWithCallbackMethod_Set<ExperimentalWithCallbackMethod_Subscribe<Service > > > > CallbackService;
  #endif

    typedef ExperimentalWithCallbackMethod_Capabilities<ExperimentalWithCallbackMethod_Get<ExperimentalWithCallbackMethod_Set<ExperimentalWithCallbackMethod_Subscribe<Service > > > > ExperimentalCallbackService;
    template <class BaseClass>
    class WithGenericMethod_Capabilities : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithGenericMethod_Capabilities()
        {
            ::grpc::Service::MarkMethodGeneric(0);
        }
        ~WithGenericMethod_Capabilities() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Capabilities(::grpc::ServerContext * /*context*/, const ::gnmi::CapabilityRequest * /*request*/, ::gnmi::CapabilityResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_Get : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithGenericMethod_Get()
        {
            ::grpc::Service::MarkMethodGeneric(1);
        }
        ~WithGenericMethod_Get() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Get(::grpc::ServerContext * /*context*/, const ::gnmi::GetRequest * /*request*/, ::gnmi::GetResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_Set : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithGenericMethod_Set()
        {
            ::grpc::Service::MarkMethodGeneric(2);
        }
        ~WithGenericMethod_Set() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Set(::grpc::ServerContext * /*context*/, const ::gnmi::SetRequest * /*request*/, ::gnmi::SetResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_Subscribe : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithGenericMethod_Subscribe()
        {
            ::grpc::Service::MarkMethodGeneric(3);
        }
        ~WithGenericMethod_Subscribe() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Subscribe(::grpc::ServerContext * /*context*/, ::grpc::ServerReaderWriter< ::gnmi::SubscribeResponse, ::gnmi::SubscribeRequest> * /*stream*/)  override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithRawMethod_Capabilities : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithRawMethod_Capabilities()
        {
            ::grpc::Service::MarkMethodRaw(0);
        }
        ~WithRawMethod_Capabilities() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Capabilities(::grpc::ServerContext * /*context*/, const ::gnmi::CapabilityRequest * /*request*/, ::gnmi::CapabilityResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void
        RequestCapabilities(::grpc::ServerContext *context, ::grpc::ByteBuffer *request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer> *response, ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq, void *tag)
        {
            ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_Get : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithRawMethod_Get()
        {
            ::grpc::Service::MarkMethodRaw(1);
        }
        ~WithRawMethod_Get() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Get(::grpc::ServerContext * /*context*/, const ::gnmi::GetRequest * /*request*/, ::gnmi::GetResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void
        RequestGet(::grpc::ServerContext *context, ::grpc::ByteBuffer *request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer> *response, ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq, void *tag)
        {
            ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_Set : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithRawMethod_Set()
        {
            ::grpc::Service::MarkMethodRaw(2);
        }
        ~WithRawMethod_Set() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Set(::grpc::ServerContext * /*context*/, const ::gnmi::SetRequest * /*request*/, ::gnmi::SetResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void
        RequestSet(::grpc::ServerContext *context, ::grpc::ByteBuffer *request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer> *response, ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq, void *tag)
        {
            ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_Subscribe : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithRawMethod_Subscribe()
        {
            ::grpc::Service::MarkMethodRaw(3);
        }
        ~WithRawMethod_Subscribe() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Subscribe(::grpc::ServerContext * /*context*/, ::grpc::ServerReaderWriter< ::gnmi::SubscribeResponse, ::gnmi::SubscribeRequest> * /*stream*/)  override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void
        RequestSubscribe(::grpc::ServerContext *context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer> *stream, ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq, void *tag)
        {
            ::grpc::Service::RequestAsyncBidiStreaming(3, context, stream, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_Capabilities : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        ExperimentalWithRawCallbackMethod_Capabilities()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(0,
                                  new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                                      [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                          ::grpc::CallbackServerContext *
    #else
                                          ::grpc::experimental::CallbackServerContext *
    #endif
                                          context, const ::grpc::ByteBuffer * request, ::grpc::ByteBuffer * response) {return this->Capabilities(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_Capabilities() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Capabilities(::grpc::ServerContext * /*context*/, const ::gnmi::CapabilityRequest * /*request*/, ::gnmi::CapabilityResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor *Capabilities(
            ::grpc::CallbackServerContext * /*context*/, const ::grpc::ByteBuffer * /*request*/, ::grpc::ByteBuffer * /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor * Capabilities(
            ::grpc::experimental::CallbackServerContext * /*context*/, const ::grpc::ByteBuffer * /*request*/, ::grpc::ByteBuffer * /*response*/)
    #endif
        {
            return nullptr;
        }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_Get : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        ExperimentalWithRawCallbackMethod_Get()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(1,
                                  new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                                      [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                          ::grpc::CallbackServerContext *
    #else
                                          ::grpc::experimental::CallbackServerContext *
    #endif
                                          context, const ::grpc::ByteBuffer * request, ::grpc::ByteBuffer * response) {return this->Get(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_Get() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Get(::grpc::ServerContext * /*context*/, const ::gnmi::GetRequest * /*request*/, ::gnmi::GetResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor *Get(
            ::grpc::CallbackServerContext * /*context*/, const ::grpc::ByteBuffer * /*request*/, ::grpc::ByteBuffer * /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor * Get(
            ::grpc::experimental::CallbackServerContext * /*context*/, const ::grpc::ByteBuffer * /*request*/, ::grpc::ByteBuffer * /*response*/)
    #endif
        {
            return nullptr;
        }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_Set : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        ExperimentalWithRawCallbackMethod_Set()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(2,
                                  new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                                      [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                          ::grpc::CallbackServerContext *
    #else
                                          ::grpc::experimental::CallbackServerContext *
    #endif
                                          context, const ::grpc::ByteBuffer * request, ::grpc::ByteBuffer * response) {return this->Set(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_Set() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Set(::grpc::ServerContext * /*context*/, const ::gnmi::SetRequest * /*request*/, ::gnmi::SetResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor *Set(
            ::grpc::CallbackServerContext * /*context*/, const ::grpc::ByteBuffer * /*request*/, ::grpc::ByteBuffer * /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor * Set(
            ::grpc::experimental::CallbackServerContext * /*context*/, const ::grpc::ByteBuffer * /*request*/, ::grpc::ByteBuffer * /*response*/)
    #endif
        {
            return nullptr;
        }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_Subscribe : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        ExperimentalWithRawCallbackMethod_Subscribe()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(3,
                                  new ::grpc_impl::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                                      [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                          ::grpc::CallbackServerContext *
    #else
                                          ::grpc::experimental::CallbackServerContext *
    #endif
                                          context) {return this->Subscribe(context); }));
        }
        ~ExperimentalWithRawCallbackMethod_Subscribe() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable synchronous version of this method */
        ::grpc::Status
        Subscribe(::grpc::ServerContext * /*context*/, ::grpc::ServerReaderWriter< ::gnmi::SubscribeResponse, ::gnmi::SubscribeRequest> * /*stream*/)  override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer> *Subscribe(
            ::grpc::CallbackServerContext * /*context*/)
    #else
        virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer> *Subscribe(
            ::grpc::experimental::CallbackServerContext * /*context*/)
    #endif
        {
            return nullptr;
        }
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_Capabilities : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithStreamedUnaryMethod_Capabilities()
        {
            ::grpc::Service::MarkMethodStreamed(0,
                                                new ::grpc::internal::StreamedUnaryHandler<
                                                    ::gnmi::CapabilityRequest, ::gnmi::CapabilityResponse>(
                                                    [this](::grpc_impl::ServerContext * context,
                                                           ::grpc_impl::ServerUnaryStreamer<
                                                               ::gnmi::CapabilityRequest, ::gnmi::CapabilityResponse> *streamer) {
                                                        return this->StreamedCapabilities(context,
                                                                                          streamer);
                                                    }));
        }
        ~WithStreamedUnaryMethod_Capabilities() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable regular version of this method */
        ::grpc::Status
        Capabilities(::grpc::ServerContext * /*context*/, const ::gnmi::CapabilityRequest * /*request*/, ::gnmi::CapabilityResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        /* replace default version of method with streamed unary */
        virtual ::grpc::Status StreamedCapabilities(::grpc::ServerContext *context, ::grpc::ServerUnaryStreamer< ::gnmi::CapabilityRequest, ::gnmi::CapabilityResponse> *server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_Get : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithStreamedUnaryMethod_Get()
        {
            ::grpc::Service::MarkMethodStreamed(1,
                                                new ::grpc::internal::StreamedUnaryHandler<
                                                    ::gnmi::GetRequest, ::gnmi::GetResponse>(
                                                    [this](::grpc_impl::ServerContext * context,
                                                           ::grpc_impl::ServerUnaryStreamer<
                                                               ::gnmi::GetRequest, ::gnmi::GetResponse> *streamer) {
                                                        return this->StreamedGet(context,
                                                                                 streamer);
                                                    }));
        }
        ~WithStreamedUnaryMethod_Get() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable regular version of this method */
        ::grpc::Status
        Get(::grpc::ServerContext * /*context*/, const ::gnmi::GetRequest * /*request*/, ::gnmi::GetResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        /* replace default version of method with streamed unary */
        virtual ::grpc::Status StreamedGet(::grpc::ServerContext *context, ::grpc::ServerUnaryStreamer< ::gnmi::GetRequest, ::gnmi::GetResponse> *server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_Set : public BaseClass {
private:
        void
        BaseClassMustBeDerivedFromService(const Service * /*service*/)
        {
        }
public:
        WithStreamedUnaryMethod_Set()
        {
            ::grpc::Service::MarkMethodStreamed(2,
                                                new ::grpc::internal::StreamedUnaryHandler<
                                                    ::gnmi::SetRequest, ::gnmi::SetResponse>(
                                                    [this](::grpc_impl::ServerContext * context,
                                                           ::grpc_impl::ServerUnaryStreamer<
                                                               ::gnmi::SetRequest, ::gnmi::SetResponse> *streamer) {
                                                        return this->StreamedSet(context,
                                                                                 streamer);
                                                    }));
        }
        ~WithStreamedUnaryMethod_Set() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        /* disable regular version of this method */
        ::grpc::Status
        Set(::grpc::ServerContext * /*context*/, const ::gnmi::SetRequest * /*request*/, ::gnmi::SetResponse * /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        /* replace default version of method with streamed unary */
        virtual ::grpc::Status StreamedSet(::grpc::ServerContext *context, ::grpc::ServerUnaryStreamer< ::gnmi::SetRequest, ::gnmi::SetResponse> *server_unary_streamer) = 0;
    };
    typedef WithStreamedUnaryMethod_Capabilities<WithStreamedUnaryMethod_Get<WithStreamedUnaryMethod_Set<Service > > > StreamedUnaryService;
    typedef Service SplitStreamedService;
    typedef WithStreamedUnaryMethod_Capabilities<WithStreamedUnaryMethod_Get<WithStreamedUnaryMethod_Set<Service > > > StreamedService;
};

}  /* namespace gnmi */


#endif  /* GRPC_gnmi_2eproto__INCLUDED */
