<!DOCTYPE html>
<html>
<head>
<title>http.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="http-11%E7%89%88%E6%9C%AC">HTTP 1.1版本</h1>
<h2 id="%E7%AC%AC%E4%B8%80%E7%AB%A0-http%E6%A6%82%E8%BF%B0">第一章 HTTP概述</h2>
<h3 id="11-http%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90">1.1 HTTP的系统组成</h3>
<p>  HTTP是一个客户端——服务器协议：请求有一个实体，即用户代理(user agent)，或是一个可以代表它的代理方(proxy)发出。每个请求都会被发送到一个服务器，它会处理这个请求并提供一个称作响应的回复。在客户端与服务器之间，还有许许多多的被称为代理的实体，履行不同的作用，例如充当网关或缓存。</p>
<p align="center">
  <img src="file:///c:/Users/jiaweq1/OneDrive - kochind.com/Desktop/c_project/c_project_win/http/image.png">
</p>  
&#x2003;&#x2003;&#x5982;&#x56FE;&#xFF1A;A&#x3001;B &#x548C; C &#x4E3A;&#x4E2D;&#x4ECB;&#xFF0C;v &#x4E3A;&#x94FE;&#x8DEF;&#x3002;&#x5728;&#x4E00;&#x4E2A;&#x8BF7;&#x6C42;/&#x54CD;&#x5E94;&#x4E2D;&#x51FA;&#x73B0;&#x4E00;&#x4E2A;&#x6216;&#x8005;&#x591A;&#x4E2A;&#x4E2D;&#x4ECB;&#x65F6;&#xFF0C;&#x5C31;&#x662F;&#x590D;&#x6742;&#x7684;&#x60C5;&#x51B5;&#x4E86;&#x3002;&#x4E2D;&#x4ECB;&#x6709;&#x4E09;&#x79CD;&#x5E38;&#x89C1;&#x5F62;&#x5F0F;&#xFF1A;&#x4EE3;&#x7406;&#x3001;&#x7F51;&#x5173;&#x548C;&#x96A7;&#x9053;&#x3002;&#x4EE3;&#x7406;&#x662F;&#x4E00;&#x4E2A;&#x8F6C;&#x53D1;&#x4EE3;&#x7406;&#xFF0C;&#x63A5;&#x6536;&#x4EE5;&#x7EDD;&#x5BF9;&#x5F62;&#x5F0F;&#x7684; URI &#x53D1;&#x9001;&#x7684;&#x8BF7;&#x6C42;&#xFF0C;&#x91CD;&#x5199;&#x6D88;&#x606F;&#x7684;&#x5168;&#x90E8;&#x6216;&#x90E8;&#x5206;&#xFF0C;&#x5E76;&#x5C06;&#x91CD;&#x65B0;&#x683C;&#x5F0F;&#x5316;&#x7684;&#x8BF7;&#x6C42;&#x8F6C;&#x53D1;&#x5230;&#x7531; URI &#x6807;&#x8BC6;&#x7684;&#x670D;&#x52A1;&#x5668;&#x3002;&#x7F51;&#x5173;&#x662F;&#x4E00;&#x4E2A;&#x63A5;&#x6536;&#x4EE3;&#x7406;&#xFF0C;&#x53EF;&#x4F5C;&#x4E3A;&#x5176;&#x4ED6;&#x67D0;&#x4E9B;&#x670D;&#x52A1;&#x5668;&#x7684;&#x4E00;&#x5C42;&#xFF0C;&#x6709;&#x5FC5;&#x8981;&#x65F6;&#x5C06;&#x8BF7;&#x6C42;&#x8F6C;&#x6362;&#x4E3A;&#x57FA;&#x7840;&#x670D;&#x52A1;&#x5668;&#x7684;&#x534F;&#x8BAE;&#x3002;&#x96A7;&#x9053;&#x5145;&#x5F53;&#x4E24;&#x4E2A;&#x8FDE;&#x63A5;&#x4E4B;&#x95F4;&#x7684;&#x4E2D;&#x7EE7;&#x70B9;&#xFF0C;&#x4E0D;&#x6539;&#x53D8;&#x6D88;&#x606F;&#xFF1B;&#x5F53;&#x901A;&#x4FE1;&#x9700;&#x8981;&#x901A;&#x8FC7;&#x4E2D;&#x4ECB;&#xFF08;&#x5982;&#x9632;&#x706B;&#x5899;&#xFF09;&#x4F20;&#x9012;&#x65F6;&#xFF0C;&#x4F1A;&#x4F7F;&#x7528;&#x96A7;&#x9053;&#xFF0C;&#x5373;&#x4F7F;&#x4E2D;&#x4ECB;&#x4E0D;&#x80FD;&#x7406;&#x89E3;&#x6D88;&#x606F;&#x7684;&#x5185;&#x5BB9;&#x3002;
<h3 id="12-http%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8">1.2 HTTP的基本性质</h3>
<ul>
<li><strong>HTTP是简约的</strong>：HTTP报文能被人读懂并理解，向开发者提供了简单的测试方式。(在HTTP 2.0中，HTTP报文消息被封装进入帧，这点引入了额外的复杂度)</li>
<li><strong>HTTP是可扩展的</strong>： HTTP 标头让该协议易于扩展和实验。只要服务器客户端之间对新标头的语义经过简单协商，新功能就可以被加入进来。</li>
<li><strong>HTTP无状态，但有会话</strong>：无状态：在同一个连接中，前后两个执行成功的请求之间是没有关系的。<strong>基于Cookie和Session的会话管理</strong>：采用Session(服务端)、Sessionid(标识符)和Cookie 被加入协议工作流程，每个请求之间就能创建会话，让每个请求都能共享上下文信息或相同的状态。<strong>基于Token的会话管理.....</strong></li>
<li><strong>HTTP和连接</strong>：由传输层来控制，仅仅需要传输层是可靠的，或不会丢失消息。在 HTTP/1.1 里，默认就是长连接的。</li>
</ul>
<h3 id="13-http%E8%83%BD%E6%8E%A7%E5%88%B6%E4%BB%80%E4%B9%88">1.3 HTTP能控制什么</h3>
<ul>
<li><strong>缓存</strong>：服务端能指示代理和客户端缓存哪些内容以及缓存多长时间，客户端能够指示中间的缓存代理来忽略已存储的文档。</li>
<li><strong>开放同源限制</strong>：</li>
<li><strong>认证</strong>：一些页面可能会被保护起来，仅让特定的用户进行访问。</li>
<li><strong>代理服务器和隧道</strong>：服务器或客户端常常是处于内网的，对其他计算机隐藏真实 IP 地址。因此 HTTP 请求就要通过代理服务器越过这个网络屏障。</li>
</ul>
<h2 id="%E7%AC%AC%E4%BA%8C%E7%AB%A0-http%E7%9A%84%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94">第二章 HTTP的请求——响应</h2>
<h3 id="21-http%E4%BC%9A%E8%AF%9D">2.1 HTTP会话</h3>
<ul>
<li><strong>建立连接</strong>：TCP三次握手</li>
<li><strong>发送请求</strong>：客户端向服务器发送请求，请求中包含要访问的资源的 URL、请求方法（GET、POST、PUT、DELETE 等）、请求头（例如，Accept、User-Agent）以及可选的请求体（对于 POST 或 PUT 请求）。</li>
<li><strong>处理请求</strong>：服务器处理请求并送回应答，回应包括一个状态码和对应的数据。</li>
<li><strong>关闭连接</strong>：TCP四次挥手。</li>
</ul>
<h3 id="22-http%E8%AF%B7%E6%B1%82">2.2 HTTP请求</h3>
<p align="center">
  <img src="file:///c:/Users/jiaweq1/OneDrive - kochind.com/Desktop/c_project/c_project_win/http/image-5.png">
</p> 
<ul>
<li><strong>起始行</strong>(start-line)：三元素：一个HTTP方法、一个请求目标和HTTP版本。</li>
<li><strong>标头</strong>(Header)：<strong>通用标头(General header)</strong> 适用于请求消息和响应消息。<strong>请求标头(Request header)</strong> 通过进一步的定义给定上下文给或者进行有条件的限制来修饰请求。<strong>表示标头(Representation header)</strong> 描述了消息数据的原始格式和应用编码(仅在消息有主体时才存在)。</li>
<li><strong>主体</strong>(Body)：常见的POST请求会有主体。主体大致可分为两类：单一资源主体和多资源主体</li>
</ul>
<h3 id="23-http%E5%93%8D%E5%BA%94">2.3 HTTP响应</h3>
<p align="center">
  <img src="file:///c:/Users/jiaweq1/OneDrive - kochind.com/Desktop/c_project/c_project_win/http/image-6.png">
</p> 
<ul>
<li><strong>状态行</strong>(status-line)：三元素：一个HTTP版本、一个状态码和状态文本。</li>
<li><strong>标头</strong>(Header)：<strong>通用标头(General header)</strong> 适用于请求消息和响应消息。<strong>请求标头(Request header)</strong> 提供有关服务器的其他信息，这些消息不适合状态行。<strong>表示标头(Representation header)</strong> 描述了消息数据的原始格式和应用编码(仅在消息有主体时才存在)。</li>
<li><strong>主体</strong>(Body)：主体大致可分为三类：单一资源主体，由<em>已知</em> s长度的单个文件组成该类型主体由两个标头定义：Content-Type 和 Content-Length。单资源主体，由<em>未知</em> 长度的单个文件组成通过将Transfer-Encoding 设置为 chunked 来使用分块编码。多资源主体，由多部份body组成，每个部分包含不同的信息段。</li>
</ul>
<h2 id="%E7%AC%AC%E4%B8%89%E7%AB%A0-http%E9%87%8D%E8%A6%81%E5%8A%9F%E8%83%BD">第三章 HTTP重要功能</h2>
<h3 id="31-http-%E5%AE%89%E5%85%A8">3.1 HTTP 安全</h3>
<h3 id="31-http-%E6%8E%A7%E5%88%B6%E8%AE%BF%E9%97%AEcors">3.1 HTTP 控制访问(CORS)</h3>
<p>  跨源资源共享（CORS，或通俗地译为跨域资源共享）是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其他源（域、协议或端口），使得浏览器允许这些源访问加载自己的资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。</p>
<p align="center">
  <img src="file:///c:/Users/jiaweq1/OneDrive - kochind.com/Desktop/c_project/c_project_win/http/image-4.png">
</p>
<p>  如图所示在<code>https://domian-a.com</code>的 JavaScrip 代码对<code>https://domain-b.com/data.json</code>发出了请求，但出于安全性，浏览器对于脚本内发出的<strong>跨源HTTP请求</strong>进行了限制。这意味着使用 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源，除非响应报文包含了正确 CORS 响应头。CORS 机制允许 Web 应用服务器进行跨源访问控制，从而使跨源数据传输得以安全进行。</p>
<h3 id="32-http-%E8%AE%A4%E8%AF%81">3.2 HTTP 认证</h3>
<p>  HTTP 提供一个用于权限控制和认证的通用框架。下面步骤介绍了通用的 HTTP 认证框架，服务器可以用来质询（challenge）客户端的请求，客户端则可以提供身份验证凭据：<br>
  1.服务器端向客户端返回 401（Unauthorized，未被授权的）响应状态码，并在 WWW-Authenticate 响应标头提供如何进行验证的信息，其中至少包含有一种质询方式。<br>
  2.之后，想要使用服务器对自己身份进行验证的客户端，可以通过包含凭据的 Authorization 请求标头进行验证。<br>
  3.通常，客户端会向用户显示密码提示，然后发送包含正确的 Authorization 标头的请求。</p>
<h3 id="33-http-%E7%BC%93%E5%AD%98">3.3 HTTP 缓存</h3>
<h4 id="331-%E6%A6%82%E8%A7%88">3.3.1 概览</h4>
<p>  HTTP通常用于分布信息系统，在这些系统中，可以通过使用响应缓存来提高性能。 HTTP/1.1协议包括许多旨在使缓存尽可能工作的元素。由于这些元素与协议的其他方面密不可分，并且彼此互动，因此有必要将HTTP的基本缓存设计与方法、标题、响应代码等的详细描述分开描述。
  HTTP/1.1 中缓存的目标是在许多情况下消除发送请求的需要，并在许多其他情况下消除发送完整响应的需要。前者减少了许多操作所需的网络往返次数；我们使用 <strong>&quot;expiration&quot;(过期)</strong> 机制来实现这一目的。后者减少了网络带宽要求；我们使用 <strong>&quot;validation&quot;(验证)</strong> 机制来实现这一目的。</p>
<h4 id="332-expiration%E8%BF%87%E6%9C%9F">3.3.2 expiration(过期)</h4>
<p>  存储的 HTTP 响应有两种状态：fresh 和 stale。fresh 状态通常表示响应仍然有效，可以重复使用，而 stale 状态表示缓存的响应已经过期。在HTTP/1.1中采用<code>max-age</code>指令，指定了允许重用缓存的response的最长时间（以秒为单位）。例如，max-age=60表示response可以缓存，并且在接下来的60s内可以被重用，无需发出新的request请求。</p>
<h4 id="333-validation%E9%AA%8C%E8%AF%81">3.3.3 validation(验证)</h4>
<p>  过时的响应不会立即被丢弃。HTTP 有一种机制，可以通过询问源服务器将陈旧的响应转换为新的响应。这称为验证，有时也称为重新验证。
  验证是通过使用包含<code>If-Modified-Since</code>或 <code>If-None-Match</code>请求标头的条件请求完成的。</p>
<pre><code>  1.使用 max-age/If-Modified-Since 的时候，如果内容没有更改，服务器响应 304 Not Modifird 。
  2.使用 ETag/If-None-Match 的时候，如果服务器为请求的资源确定的 ETag 标头的值与请求中的 If-None-Match 值相同，
  则服务器将返回 304 Not Modified。但是，如果服务器确定请求的资源现在应该具有不同的 ETag 值，
  则服务器将其改为 200 OK 和资源的最新版本进行响应。
</code></pre>
<h4 id="335-%E4%B8%8D%E5%90%8C%E7%A7%8D%E7%B1%BB%E7%9A%84%E7%BC%93%E5%AD%98">3.3.5 不同种类的缓存</h4>
<p>  <strong>私有缓存</strong>是绑定到特定哭护短的缓存————通常是浏览器缓存。由于存储的响应不与其他客户端共享，因此私有缓存可以存储该用户的个性化响应。</p>
<pre><code> HTTP响应： Cache-Control: private
</code></pre>
<p>  <strong>共享缓存</strong>是位于客户端与服务端之间，可以存储用户之间共享的响应。共享缓存可以进一步细分为<strong>代理缓存</strong>和<strong>托管缓存</strong>。<br>
  1.代理缓存：除了访问控制的功能外，一些代理还实现了缓存以减少网络流量。</p>
<pre><code>  Cache-Control: no-store, no-cache, max-age=0, must-revalidate, proxy-revalidate （全实现）
  no-store：指示缓存不应存储任何关于请求/响应的内容。
  no-cache：指示缓存不应使用缓存的内容，而是每次都需要向服务器发送请求进行验证。该指令不会阻止存储响应，而是阻止在不重新验证的情况下重用响应
  max-age=0：指示缓存中的内容已经过期，需要向服务器发送请求进行验证。
  must-revalidate：指示缓存在过期后必须向服务器发送请求进行验证。
  proxy-revalidate：指示代理服务器在缓存内容过期后必须向原始服务器发送请求进行验证。
</code></pre>
<p>  2.托管缓存：托管缓存由服务开发人员明确部署，以降低源服务器负载并有效地交付内容。</p>
<pre><code>  Cache-Control: no-store
</code></pre>
<h3 id="34-http-%E5%8E%8B%E7%BC%A9">3.4 HTTP 压缩</h3>
<p>  数据压缩是提高 Web 站点性能的一种重要手段。对于有些文件来说，高达 70% 的压缩比率可以大大减低对于带宽的需求。用于文件的压缩算法可以大致分为两类：</p>
<ul>
<li><strong>无损压缩</strong>：在压缩与解压缩的循环期间，不会对要恢复的数据进行修改。复原后的数据与原始数据是一致的（比特与比特之间一一对应）。如：图片文件<code>gif</code>或者<code>ping</code></li>
<li><strong>有损压缩</strong>：在压缩与解压缩的循环期间，会对原始数据进行修改，但是会（希望）以用户无法觉察的方式进行。如：网络上的视频文件，<code>jpeg</code>格式的图片。</li>
</ul>
<h3 id="35-http-%E6%9D%A1%E4%BB%B6%E8%AF%B7%E6%B1%82">3.5 HTTP 条件请求</h3>
<p>  在 HTTP 中有一个条件请求的概念，在这类请求中，请求的结果，甚至请求成功的状态，都会随着验证器与受影响资源的比较结果的变化而变化。这类请求可以用来验证缓存的有效性，省去不必要的控制手段，以及验证文件的完整性，例如在断点续传的场景下或者在上传或者修改服务器端的文件的时候避免更新丢失问题。</p>
<h4 id="351-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">3.5.1 基本原理</h4>
<p>  在 HTTP 协议中，条件请求指的是请求的执行结果会因特定首部的值不同而不同。这些首部规定了请求的前置条件，请求结果则视条件匹配与否而有所不同。</p>
<h4 id="352-%E9%AA%8C%E8%AF%81%E5%99%A8">3.5.2 验证器</h4>
<p>  所有的条件请求首部都是试图去检测服务器上存储的资源是否与某一特定版本相匹配。而验证器的类型分为两大类:文件最后修改时间 <code>last-modified</code> 和 实体标签 <code>ETag</code>。<br>
  比较同一份资源的不同版本有一定的技巧性：取决于上下文环境的不同，有两种不同的等值检查类型：</p>
<ul>
<li><em>强验证类型（Strong validation）</em> 应用于需要逐个字节相对应的情况，例如需要进行断点续传的时候</li>
<li><em>弱验证类型（Weak validation）</em> 应用于用户代理只需要确认资源内容相同即可。即便是有细微差别也可以接受，比如显示的广告不同，或者是页脚的时间不同。</li>
</ul>
<h4 id="353-%E6%9D%A1%E4%BB%B6%E9%A6%96%E9%83%A8">3.5.3 条件首部</h4>
<pre><code>  If-Match
  如果远端资源的实体标签与在 ETag 这个首部中列出的值相同的话，表示条件匹配成功。默认地，除非实体标签带有 'W/' 前缀，否者它将会执行强验证。

  If-None-Match
  如果远端资源的实体标签与在 ETag 这个首部中列出的值都不相同的话，表示条件匹配成功。默认地，除非实体标签带有 'W/' 前缀，否者它将会执行强验证。

  If-Modified-Since
  如果远端资源的 Last-Modified 首部标识的日期比在该首部中列出的值要更晚，表示条件匹配成功。

  If-Unmodified-Since
  如果远端资源的 HTTPHeader(&quot;Last-Modified&quot;)}} 首部标识的日期比在该首部中列出的值要更早或相同，表示条件匹配成功。

  If-Range
  与 If-Match 或 If-Unmodified-Since 相似，但是只能含有一个实体标签或者日期值。如果匹配失败，则条件请求宣告失败，此时将不会返回 206 Partial Content 响应码，而是返回 200 OK 响应码，以及完整的资源。
</code></pre>
<h3 id="36-http-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86">3.6 HTTP 内容协商</h3>
<p>  在 HTTP 协议中，内容协商是一种机制，用于为同一 URI 提供资源不同的表示形式，以帮助用户代理指定最适合用户的表示形式（例如，哪种文档语言、哪种图片格式或者哪种内容编码）。
  最佳表示形式的选取可以通过两种机制实现：</p>
<ul>
<li>客户端设置特定的 HTTP 标头（又称为服务端驱动型内容协商或者主动内容协商），这是进行内容协商的标准方式。</li>
<li>服务器返回 <code>300（Multiple Choices）或者 406（Not Acceptable）、415（Unsupported Media Type）HTTP 响应状态码 （又称为代理驱动型协商或者响应式协商）</code>，这种方式一般用作备选方案。</li>
</ul>
<h3 id="37-http-cookie">3.7 HTTP Cookie</h3>
<h4 id="371-cookie-%E6%A6%82%E8%BF%B0">3.7.1 Cookie 概述</h4>
<p>  HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据。浏览器会存储 cookie 并在下次向同一服务器再发起请求时携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器——如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。<br>
  Cookie主要用于三个方面：会话状态管理、个性化设置、浏览器行为跟踪。</p>
<h4 id="372-cookie%E5%88%9B%E5%BB%BA">3.7.2 Cookie创建</h4>
<p>  服务器使用 Set-Cookie 响应头部向用户代理（一般是浏览器）发送 Cookie 信息。一个简单的 Cookie 可能像这样：</p>
<pre><code>  Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;
</code></pre>
<p>  设置完成之后，对该服务器发起的每一次新请求，浏览器都会将之前保存的 Cookie 信息通过 Cookie 请求头部再发送给服务器。</p>
<pre><code>  GET /sample_page.html HTTP/1.1
  Host: www.example.org
  Cookie: yummy_cookie=choco; tasty_cookie=strawberry
</code></pre>
<h3 id="38-http-%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82">3.8 HTTP 范围请求</h3>
<p>  HTTP 的 Range 请求使客户端能够要求服务器仅向其回传 HTTP 消息的一部分。范围请求对于支持随机访问的媒体播放器、明确只需大型文件某部分的数据处理工具，以及允许用户暂停及恢复下载的下载管理器等客户端尤其有用。<br>
  请求示例：</p>
<pre><code>  GET /example.mp4 HTTP/1.1
  Host: www.example.com
  Range: bytes=0-999
</code></pre>
<p>  响应示例：</p>
<pre><code>  HTTP/1.1 206 Partial Content
  Content-Range: bytes 0-999/1234567
  Content-Length: 1000
  Content-Type: video/mp4

  [前1000字节的内容]
</code></pre>
<h3 id="39-http-%E9%87%8D%E5%AE%9A%E5%90%91">3.9 HTTP 重定向</h3>
<p>  URL 重定向（也称为 URL 转发）是一种为页面、表单或者整个 Web 站点/应用提供多个 URL 地址的技术。HTTP 对此操作有一种特殊类型的响应，称为 HTTP 重定向（HTTP redirect）。<br>
  在 HTTP 协议中，重定向操作由服务器向请求发送特殊的重定向响应而触发。重定向响应包含以 3 开头的状态码，以及 Location 标头，其保存着重定向的 URL。<br>
  浏览器在接收到重定向时，它们会立刻加载 Location 标头中提供的新 URL。除了额外的往返操作中会有一小部分性能损失之外，重定向操作对于用户来说是不可见的。</p>
<h2 id="%E7%AC%AC%E5%9B%9B%E7%AB%A0-http%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E8%81%94%E7%B3%BBrest">第四章 HTTP基本内容（联系REST）</h2>
<h3 id="41-http%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95">4.1 HTTP的主要方法</h3>
<ul>
<li>
<p>GET(幂等)：请求获取资源。————REST资源查询</p>
<pre><code>E.g：GET /index.html
</code></pre>
</li>
<li>
<p>POST(不是幂等)：请求服务器接收并处理请求体中的数据，常用于表单提交。————REST资源的创建</p>
<pre><code>E.g:  POST /users HTTP/1.1
      Host: api.example.com
      Content-Type: application/json

      {
      &quot;name&quot;: &quot;John Doe&quot;,
      &quot;age&quot;: 30,
      &quot;email&quot;: &quot;john.doe@example.com&quot;
      }
</code></pre>
</li>
<li>
<p>PUT(幂等)：请求服务器存储一个资源，并用请求体中的内容替换目标资源的所有内容。————REST资源的更新</p>
<pre><code>E.g： PUT /users/1 HTTP/1.1
      Host: api.example.com
      Content-Type: application/json

      {
      &quot;name&quot;: &quot;John Doe&quot;,
      &quot;age&quot;: 31,
      &quot;email&quot;: &quot;john.doe@example.com&quot;
      }
</code></pre>
</li>
<li>
<p>PATCH(不是幂等)：PATCH用于更新部分资源。当客户端使用 PATCH 方法向服务器发送请求时，服务器将更新与请求 URI 相关联的资源的部分属性。————REST资源的更新</p>
<pre><code>E.g：PATCH /users/1 HTTP/1.1
     Host: api.example.com
     Content-Type: application/json

     {
        &quot;age&quot;: 31
     }       
</code></pre>
</li>
<li>
<p>DELETE(幂等):请求　服务器删除指定资源。————REST资源的删除。</p>
<pre><code>E.g: DELETE /file.html HTTP/1.1
</code></pre>
</li>
</ul>
<p></p>
<h3 id="42-http%E7%9A%84%E8%BF%94%E5%9B%9E%E7%8A%B6%E6%80%81%E7%A0%81">4.2 HTTP的返回状态码</h3>
<ul>
<li>1xx：表示接收的请求正在处理。————REST并没有使用</li>
<li>2xx：表示请求正常处理完毕。</li>
<li>3xx：需要后续操作才能完成这一请求。</li>
<li>4xx：表示请求包含语法错误或无法完成.</li>
<li>5xx：服务器在处理请求的过程中发生了错误。</li>
</ul>
<h3 id="43-%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81">4.3 常用状态码</h3>
<h4 id="200-ok">200 OK</h4>
<p>  HTTP状态码<code>200 OK</code>表明请求已经成功。默认情况下状态码为 200 的响应可以被缓存。
  不同的请求方式对于请求成功的意义如下：</p>
<ul>
<li><em>GET</em>: 已经取得资源，并将资源添加到响应的消息体中。</li>
<li><em>HEAD</em>: 响应的消息体为头部信息。</li>
<li><em>POST</em>: 响应的消息体中包含此次请求的结果。</li>
<li><em>TRACE</em>: 响应的消息体中包含服务器接收到的请求信息。</li>
<li><em>DELETE</em>：操作已执行，并且响应中提供了相关状态的描述信息。</li>
</ul>
<h4 id="201-created">201 Created</h4>
<p>  HTTP响应状态码 <code>201 Created</code> 是一个代表成功的应答状态码，表示请求已经被成功处理，并且创建了新的资源。新的资源在应答返回之前已经被创建。
  这个状态码的常规使用的场景是作为 <em>post</em> 请求的返回值。</p>
<h4 id="202-accepted">202 Accepted</h4>
<p>  HTTP响应状态码 <code>202 Accepted</code> 表示服务器端已经收到请求q息，但是尚未进行处理。但是对于请求的处理却是无保证的，即稍后无法通过 HTTP 协议给客户端发送一个异步请求来告知其请求的处理结果。这个状态码被设计用来将请求交由另外一个进程或者服务器来进行处理，或者是对请求进行批处理的情形。
  在 <em>DELETE</em> 请求中成功通常是 <code>202 No Accepted</code>表示操作可能会成功执行，但是尚未开始执行。</p>
<h4 id="204-no-content">204 No Content</h4>
<p>  HTTP响应状态码 <code>204 No Content</code> 成功状态响应码，表示该请求已经成功了，但是客户端客户不需要离开当前页面。默认情况下 204 响应是可缓存的。
  在 <em>PUT</em> 请求中进行资源更新，但是不需要改变当前展示给用户的页面，那么返回 <code>204 No Content</code>。如果创建了资源，则返回 <code>201 Created</code> 。如果应将页面更改为新更新的页面，则应改用 <code>200 OK</code> 。<br>
  在 <em>DELETE</em> 请求中成功通常是 <code>204 No Content</code>表示删除成功，但没有进一步的相关信息。</p>
<h4 id="400-bad-raquest">400 Bad Raquest</h4>
<p>  HTTP响应状态码 <code>400 Bad Request</code> 响应状态码表示服务器因某些被认为是客户端错误的原因（例如，请求语法错误、无效请求消息格式或者欺骗性请求路由），而无法或不会处理该请求。</p>
<h4 id="401-unauthorized">401 Unauthorized</h4>
<p>  HTTP响应状态码 <code>401 Unauthorized </code>代表客户端错误，指的是由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。这个状态码会与 WWW-Authenticate 首部一起发送，其中包含有如何进行验证的信息。</p>
<pre><code>  E.g: HTTP/1.1 401 Unauthorized
  Date: Wed, 21 Oct 2015 07:28:00 GMT
  WWW-Authenticate: Basic realm=&quot;Access to staging site&quot;
</code></pre>
<h4 id="403-forbidden">403 Forbidden</h4>
<p>  HTTP响应状态码 <code>403 Forbidden</code> 代表客户端错误，指的是服务器端有能力处理该请求，但是拒绝授权访问。</p>
<pre><code>  401 Unauthorized 与 403 Forbidden 的区别：  
   - 401 Unauthorized 用户身份验证错误，验证成功之后，可改变状态（例如用户的账户密码错误）。
   - 403 Forbidden 即使重新验证也不会改变该状态。该访问是长期禁止的，并且与应用逻辑密切相关（例如没有足够的权限访问该资源）。
</code></pre>
<h4 id="404-not-found">404 Not Found</h4>
<p>  HTTP 响应状态码 <code>404 Not Found</code> 指的是服务器无法找到所请求的资源。<em>404</em> 状态码并不能说明请求的资源是临时还是永久丢失。如果服务器知道该资源是永久丢失，那么应该返回 <code>410（Gone）</code> 而不是 <em>404</em>。</p>
<h4 id="405-method-not-allowed">405 Method Not Allowed</h4>
<p>  HTTP响应状态码 <code>405 Method Not Allowed</code> 表明服务器禁止了使用当前 HTTP 方法的请求（例如服务器没有该方法）。</p>
<h4 id="406-not-acceptable">406 Not Acceptable</h4>
<p>  HTTP响应状态码 <code>406 Not Acceptable</code> 表示客户端错误，指代服务器端无法提供与 <em>Accept</em> 和 <em>Accept-Language</em>、 消息头指定的值相匹配的响应。</p>
<h4 id="410-gone">410 Gone</h4>
<p>  HTTP响应状态码 <code>410 Gone</code> 说明请求的目标资源在原服务器上不存在了，并且是永久性的丢失。如果不清楚是否为永久或临时的丢失，应该使用 <em>404</em>。</p>
<h4 id="422-unprocessable-entity">422 Unprocessable Entity</h4>
<p>  HTTP响应状态码 <code>422 Unprocessable Entity</code> 表示服务器理解请求实体的内容类型，并且请求实体的语法是正确的，但是服务器无法处理所包含的指令。</p>
<h4 id="500-internal-server-error">500 Internal Server Error</h4>
<p>  HTTP响应状态码 <code>500 Internal Server Error</code> 是表示服务器端错误的响应状态码，意味着所请求的服务器遇到意外的情况并阻止其执行请求。<br>
  这个错误代码是一个通用的“万能”响应代码。有时候，对于类似于 <em>500</em> 这样的错误，服务器管理员会更加详细地记录相关的请求信息来防止以后同样错误的出现。</p>
<h2 id="htttps"><strong>HTTTPS</strong></h2>
<p>  HTTPS(端口 <strong>443</strong>) = HTTP(端口 <strong>80</strong>) + SSL/TLS</p>

</body>
</html>
